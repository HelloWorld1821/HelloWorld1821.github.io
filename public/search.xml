<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性代数</title>
      <link href="/2025/01/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2025/01/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<div style="text-align: center; margin-bottom: 35px;">  <b><i>"People will learn linear algebra three times in their life: in college, postgraduate school, and working period."</i></b></div><span id="more"></span><p>这里强烈推荐3Blue1Brown的系列视频：<a href="https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.999.0.0">线性代数的本质</a>。</p><h1 id="基向量"><a href="#基向量" class="headerlink" title="基向量"></a>基向量</h1><p>事实上，我们在初中以来的平面直角坐标系中所使用的坐标都隐含了一个条件，即我们所选择的基向量分别是沿x轴正方向和y轴正方向的单位向量，这是非常自然的，然而基向量的选择是非常多样的，空间中一个点的坐标也不是固定不变的，而是依赖于我们基向量的选择。<strong>基向量是这样一组特殊的向量，能够让向量空间中的任意向量，都可以唯一地表示成它们的线性组合。</strong>这就要求我们选择的向量组中的向量要足够“特别”，它不能被向量组中的其他向量表示，否则就不满足唯一表示这个条件。举个例子：</p><p>在$\ R^3\ $中，我们选择了$\ \vec{x},\vec{y},\vec{z}\ $这样一组向量作为基底，然而$\ \vec{z} = \vec{x} + \vec{y}$，那么对于向量$\ \vec{a} = 2\vec{x} + \vec{y}\ $来说，它还可以表示为$\ \vec{a} = \vec{x} + \vec{z}$，这就违反了基的唯一性表示原则，所以一组向量要想成为基向量，它们就彼此不能互相表示，也即<strong>线性无关</strong>。<br>基于此，我们可以定义向量空间的<strong>维度</strong>：基包含的向量个数，这里隐含了一个定理，<strong>即同一个空间中的所有基包含的向量个数一定是相同的</strong>，我们来简单证明一下：</p><p>假设现在有两组包含不同数量向量的基$V_1 = \{ \vec{x}, \vec{y}, \vec{z} \} $，$V_2 = \{ \vec{p}, \vec{q} \}$，由于$\ V_2\ $是基，我们可以得出$\ \vec{x}, \vec{y}, \vec{z}\ $均可以被$\ \vec{p}, \vec{q}\ $表示：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{array}{cc}  \vec{x} = m_1\vec{p} + n_1\vec{q}, \\  \vec{y} = m_2\vec{p} + n_2\vec{q}, \\  \vec{z} = m_3\vec{p} + n_3\vec{q}.\end{array}\right.\end{equation}</script><p>由于$\ m_1, m_2, m_3, n_1, n_2, n_3\ $均为已知数，所以下列二元一次方程($\ k, j\ $为未知数)至少有一组解：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}  km_1 &+ jm_2 = m_3, \\  kn_1 &+ jn_2 = n_3.\end{aligned}\right.\end{equation}</script><p>于是$\ \vec{z} = k\vec{x} + j\vec{y}$，这与我们基向量的线性无关性矛盾，所以凡是包含向量数量比向量空间维度大的向量组必不可能是基。</p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>首先看以下二维空间中的变换：</p><p><img src="/imgs/线性代数/线性变换.gif" style="width: 100%; height: auto;"></img></p><p>它就是线性变换 $\ L \ $，具有以下两个性质：</p><script type="math/tex; mode=display">\begin{equation}L(\vec{x} + \vec{y}) = L(\vec{x}) + L(\vec{y})\end{equation}</script><script type="math/tex; mode=display">\begin{equation}L(k \cdot \vec{x}) = k \cdot L(\vec{x})\end{equation}</script><p>通俗来说就是原来等距的点变换后依然等距，相对关系不变，并且原点不能移动，这样的变换就叫作线性变换。那么如何用数学表达式描述一个线性变换呢？<br>没错，就是矩阵！<br>对于矩阵我们并不陌生，它是排列成长方形阵列的元素集合，这里的元素可以是数字或符号甚至是函数，不过最常见的形式还是实数。尽管我们可能对矩阵乘法等各种运算已经熟稔于心，但是对于它表示的含义我们也许并不是特别清楚，它在我们眼里不过是一堆数字，但是实际上它是有着简单的几何意义的，考虑如下矩阵：</p><script type="math/tex; mode=display">\begin{equation}A = \left[\begin{array}{cc}  1 & -3 \\  5 & 2\end{array}\right]\end{equation}</script><p>将它的第一列$\ {[1 \quad 5]^T} \ $视作对基向量$\ {[1 \quad 0]^T} \ $线性变换后得到的新向量，第二列$\ {[-3 \quad 2]^T} \ $则是对基向量$\ {[0 \quad 1]^T} \ $线性变换后得到的新向量，由此就可以得出该矩阵定义了该向量空间的变换规则，只要用它左乘任何一个向量就可以得到线性变换后的新向量，首先用$\ A \ $乘以基向量：</p><script type="math/tex; mode=display">\begin{equation}\left[\begin{array}{cc}  1 & -3 \\  5 & 2\end{array}\right]\left[\begin{array}{c}  1 \\  0\end{array}\right] = \left[\begin{array}{c}  1 \\  5\end{array}\right]\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\left[\begin{array}{cc}  1 & -3 \\  5 & 2\end{array}\right]\left[\begin{array}{c}  0 \\  1\end{array}\right] = \left[\begin{array}{c}  -3 \\  2\end{array}\right]\end{equation}</script><p>这与我们$\ A \ $矩阵两列分别表示基向量变换后得到的新向量符合得很好，也从一个侧面很好的解释了为什么矩阵乘法要定义成</p><script type="math/tex; mode=display">\begin{equation}\begin{bmatrix}  a & b \\  c & d\end{bmatrix}\begin{bmatrix}  e & f \\  g & h\end{bmatrix}=\begin{bmatrix}  ae + bg & af + bh \\  ce + dg & cf + dh\end{bmatrix}\end{equation}</script><p>只有这样矩阵乘法才能表示线性变换，然而我们现在只解释了基向量的线性变换，为什么说这样一个矩阵就可以定义空间中所有向量的线性变换呢？注意到上一节中我们提到的基向量定义，空间中的所有向量都可以由基唯一表示，那么对于任何一个向量：</p><script type="math/tex; mode=display">\begin{equation}\vec{x} = m\vec{i} + n\vec{j} \quad (\vec{i}与\vec{j}为基向量)\end{equation}</script><script type="math/tex; mode=display">\begin{equation}A\vec{x} = mA\vec{i} + nA\vec{j}\end{equation}</script><p>我们可以看到变换后的新向量$ \ A\vec{x} \ $在新基$\ A\vec{i} \ 和 \ A\vec{j} \ $下的坐标还是$\ (m, \ n)$，这说明经过矩阵$\ A \ $相乘后，向量之间的相对关系并未改变，所以它是一个线性变换。<br>以上举的是<strong>方阵</strong>的例子，它表示的变换<strong>不会改变向量的维度</strong>，一个二阶矩阵乘以一个二维向量后得到的还是一个二维向量。反之如果不是方阵的话，它表示的变换<strong>则会改变向量的维度</strong>，一个$2 \times 3$大小的矩阵就表示将三维向量压缩为二维。</p><h1 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h1><p>在上一节末尾我提到方阵不会改变向量的维度，但是不代表它不会改变空间的维度，考虑以下方阵：</p><script type="math/tex; mode=display">\begin{equation}B = \left[\begin{array}{cc}  1 & 0 \\  5 & 0\end{array}\right]\end{equation}</script><p>对任意向量$\ \vec{p} = {[x \quad y ]^T}\ $，变换结果为：</p><script type="math/tex; mode=display">\begin{equation}B \vec{p} = \left[\begin{array}{c}  x \\  5x\end{array}\right]\end{equation}</script><p>可以看到变换后的所有向量均集中在直线$\ y = 5x\ $上，于是我们将空间变换成了一维。更进一步，零矩阵可以将空间压缩成零维，尽管它可能阶数很高，为了衡量这种“压缩”的能力，我们提出了<strong>秩</strong>这个概念。秩被定义为<strong>列(行)向量生成的最大线性无关组的向量个数</strong>，换句话说就是变换保留了原空间的几个维度，就像上述的$\ B \ $矩阵，秩$\ rank(B) = 1 \ $，变换后的空间也就是一维。</p><p>这里总结一下，向量的维度和空间的维度并不是一回事，尽管我们已经习惯了用二个坐标表示二维空间，三个坐标表示三维空间。向量的维度指的是向量中元素的个数，而空间的维度指的是空间中线性无关的基向量的个数，也就是空间的自由度。像上面的(12)式，尽管变换后的向量中有2个元素，但是却只用一个变量就可以表示，这就是只有一个自由度。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下cpp开发</title>
      <link href="/2025/01/08/Linux%E4%B8%8Bcpp%E5%BC%80%E5%8F%91/"/>
      <url>/2025/01/08/Linux%E4%B8%8Bcpp%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<div style="text-align: center; margin-bottom: 35px;">  <b><i>"C++ is not just a programming language, it's a philosophy of design."</i></b></div><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>linux环境在虚拟机上搭建，我使用的是VMware Workstation 17 Pro，Ubuntu版本为20.04.6桌面版。<br>1.&nbsp;&nbsp;安装g++<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure></p><p>2.&nbsp;&nbsp;安装vim<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></p><p>3.&nbsp;&nbsp;安装中文输入法(这里采用google拼音)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install fcitx-googlepinyin</span><br></pre></td></tr></table></figure></p><p style="margin-bottom: 0px;"><b>注意安装完后还得去设置里的"Region&Language"将刚安装的语言包添加进去，并且Linux中切换中英文输入法的快捷键为：win+space。</b></p>4.&nbsp;&nbsp;安装vscode(考虑到vim编辑代码不方便)，在官网选择Ubuntu系统对应的版本后下载安装包，接着使用命令行安装：<p style="margin-bottom: 20px;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i code_1.96.2-1734607745_amd64.deb</span><br></pre></td></tr></table></figure>接着在vscode界面里安装C/C++扩展，并选用g++作为编译器。# 一些概念## 编译(compile)将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序也即可执行文件，这个过程就是编译，执行这个工作的就是编译器(compiler)。我们把需要编译这个过程的称为编译型语言，典型的就是C/C++、Rust等，另外一种不需要的称为解释型语言，典型的就是Python，由于Python每次运行时都要被解释器逐行解析和执行，所以相较于提前编译好的C/C++程序运行会慢一些。例如以下命令行就是编译一个名为HelloWorld的cpp文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ HelloWorld.cpp</span><br></pre></td></tr></table></figure>不过这样编译出来的可执行文件会被命名为默认值a.out，要想自定义使用`-o`参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o HelloWorld HelloWorld.cpp</span><br></pre></td></tr></table></figure>也可以这样使用，取决于个人的使用习惯，我倾向于后一种，因为将代码文件与编译后的可执行文件名隔开了看着顺眼一些：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ HelloWorld.cpp -o HelloWorld</span><br></pre></td></tr></table></figure>## make和makefilemakefile是一个文本文件，包含了一组规则，定义了如何从源代码文件(通常是.c、.cpp、.h 文件等)构建最终的可执行文件或库。而make是一个构建工具，它会根据makefile中定义的规则来决定哪些部分的代码需要重新编译，以及如何执行这些编译和链接任务。通过使用make和makefile，可以有效地管理大型项目，避免重复编译和手动操作，极大提高开发效率。makefile的基本结构为：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: dependencies</span></span><br><span class="line">    command</span><br></pre></td></tr></table></figure>其中target是目标文件或规则的名称，dependencies是目标依赖的文件(如源代码文件、头文件)，command是在目标更新时执行的命令。例如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译目标，默认目标</span></span><br><span class="line"><span class="section">HelloWorld: HelloWorld.cpp</span></span><br><span class="line">    g++ HelloWorld.cpp -o HelloWorld</span><br><span class="line"></span><br><span class="line"><span class="comment">#清理目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f HelloWorld</span><br></pre></td></tr></table></figure>使用`make`命令时会默认选择第一个目标，如果要构建其它目标，需要显示指明就像：`make clean`，这样就会执行清理命令。make会自动识别名为“makefile”的文件并执行，如果makefile文件是其它名称，需要使用`-f`参数指定(这里makefile的文件名为“mf”)：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f mf</span><br></pre></td></tr></table></figure><p style="margin-bottom: 0px;"><b>注意书写makefile时command要使用Tab键缩进而不能使用空格，在不同的编辑器里Tab键对应的空格数量是不同的。例如：</b></p>vscode<img src="/imgs/Linux下cpp开发/vscode.png" style="width: 100%; height: auto;"></img>vim<img src="/imgs/Linux下cpp开发/vim.png" style="width: 100%; height: auto;"></img>## cmake和CMakeListscmake是一个跨平台的自动化构建系统，它能够生成用于编译、构建、测试和安装软件的标准化构建文件(如makefile)。CMakeLists是cmake使用的构建配置文件，通过它来定义项目的构建规则、依赖关系和其他设置。相较于直接用make，cmake可以生成适用于不同平台和工具链的makefile文件，更为灵活，并且自动化程度更高，简化了构建过程，减少了手动干预的需求，这使得cmake成为目前广泛使用的编译工具。CMakeLists包含了一系列cmake指令，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#声明要求的cmake最低版本</span><br><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line">#声明项目名称</span><br><span class="line"><span class="built_in">project</span>(HelloWorld)</span><br><span class="line">#添加可执行程序</span><br><span class="line">#语法：<span class="built_in">add_executable</span>(程序名 源代码文件)</span><br><span class="line"><span class="built_in">add_executable</span>(HelloWorld HelloWorld.cpp)</span><br></pre></td></tr></table></figure>一个常见的使用cmake做法为：在项目工程根目录新建build文件夹再进行编译，这样产生的中间文件就会生成在build文件夹中，与源代码分开。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>## 源文件(source file)和头文件(header file)源文件是编译的核心部分，通常是包含程序的主体逻辑、函数实现、类方法定义等具体实现的文件，具有.c（C）或.cpp（C++）的扩展名，带有main函数的源文件会被编译成可执行程序，其他的则会编译成库文件。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printHello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面这个代码文件就会被编译成库文件，因为它不带main函数。头文件一般包含函数的声明、宏定义、常量、结构体定义、类声明等，以便编译器能够知道函数、变量和类的存在，具有.h的扩展名(C++也可以使用.hpp作为扩展名)，通常不包含函数的实际实现。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printHello.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PRINTHELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTHELLO_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>最后我们如果想在主函数中调用这个函数的话，就可以这么写：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printHello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="margin-bottom: 0px;"><b>这里注意引用个人定义头文件用""，而引用标准库头文件用<>。只有使用引号才会从当前文件夹寻找，否则就会去系统配置的库环境中去寻找。</b></p><h2 id="项目整合"><a href="#项目整合" class="headerlink" title="项目整合"></a>项目整合</h2><p>有了以上的基本概念，我们就可以针对包含printHello.cpp、printHello.h和main.cpp的简单项目进行编译了。首先尝试一下makefile:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Hello: main.cpp printHello.cpp</span></span><br><span class="line">    g++ main.cpp printHello.cpp -o Hello</span><br></pre></td></tr></table></figure><br>运行成功！<br><img src="/imgs/Linux下cpp开发/makefile.png" style="width: 100%; height: auto;"></img></p><p>接着尝试一下cmake:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="built_in">project</span>(Hello)</span><br><span class="line">#添加库</span><br><span class="line"><span class="built_in">add_library</span>(printHello printHello.cpp)</span><br><span class="line">#添加可执行文件</span><br><span class="line"><span class="built_in">add_executable</span>(Hello main.cpp)</span><br><span class="line">#链接库</span><br><span class="line"><span class="built_in">target_link_libraries</span>(Hello printHello)</span><br></pre></td></tr></table></figure><br>同样运行成功！<br><img src="/imgs/Linux下cpp开发/cmake.png" style="width: 100%; height: auto;"></img></p><p>至此，我们已经具备编写c++项目的基础能力了。</p><h1 id="更新cmake"><a href="#更新cmake" class="headerlink" title="更新cmake"></a>更新cmake</h1><p>我们在上一节提到过CMakeLists中会有声明cmake最低版本的语句，所以我们编译某些包时需要升级cmake，这时候不能使用<code>sudo apt-get remove cmake</code>卸载低版本cmake后再重装高版本，这样做会导致之前编译和安装的很多库一起被卸载！！！具体步骤可以参考这篇博客 <a href="https://www.cnblogs.com/Maker-Liu/p/16550381.html">Ubuntu升级Cmake的正确方式</a></p><h1 id="遇到的一些问题及解决"><a href="#遇到的一些问题及解决" class="headerlink" title="遇到的一些问题及解决"></a>遇到的一些问题及解决</h1><h2 id="g2o库安装后编译无法找到相关文件"><a href="#g2o库安装后编译无法找到相关文件" class="headerlink" title="g2o库安装后编译无法找到相关文件"></a>g2o库安装后编译无法找到相关文件</h2><p>错误的原因是/usr/local/lib不在系统查找.so文件的路径下。需自行添加路径。具体可以参考这篇博客 <a href="https://blog.csdn.net/dieju8330/article/details/106434241">g2o安装和使用</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp开发 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Start</title>
      <link href="/2025/01/07/Start/"/>
      <url>/2025/01/07/Start/</url>
      
        <content type="html"><![CDATA[<div style="text-align: center; margin-bottom: 35px;">  <b><i>"There is no royal road to learning."</i></b></div><p style="text-align: center;">当你看到这句话时说明博客已经成功搭建，合抱之木，生于毫末；九层之台，起于累土，旅途就从这里开始吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
